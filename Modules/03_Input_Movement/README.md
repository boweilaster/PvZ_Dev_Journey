# Module 03: 事件驱动与物理运动 (Input & Movement)

## 一、 核心目标
本模块实现了从“静态显示”到“动态交互”的跨越。通过监听键盘输入，控制屏幕上的几何方块（或图片）进行实时移动。

## 二、 计算机底层逻辑知识点

### 1. 游戏循环 (The Game Loop) 架构
程序不再是线性的，而是演变为一个闭环，每一帧都经历以下三个阶段：
* **Handle Input (处理输入)**：从操作系统事件队列中提取按键信号。
* **Update (逻辑更新)**：在内存 (RAM) 中计算物体的坐标变量 ($NewPos = OldPos + Velocity$)。
* **Render (渲染呈现)**：将最终的物理状态提交给 GPU 进行像素绘制。

### 2. 事件队列 (Event Queue) 的原子性
* **逻辑**：操作系统会在两帧之间缓存所有的硬件中断（如多次按键）。
* **处理**：我们使用 `while(SDL_PollEvent)` 循环来“清空”信箱，确保每一帧都能处理完积压的所有输入，避免输入延迟。

### 3. 渲染的本质：重绘而非移动
* **底层行为**：每一帧都会执行 `SDL_RenderClear`。
* **视觉欺骗**：计算机并不是在“移动”原来的像素，而是“抹除旧的 -> 在新位置画个新的”。由于刷新率极高，肉眼产生了连续运动的幻觉。

### 4. 帧率控制 (FPS Limiting)
* **物理意义**：CPU 的运行速度远超显示器的刷新需求。
* **实现**：通过 `SDL_GetTicks()` 测量耗时，并使用 `SDL_Delay()` 强制 CPU 休眠，将程序锁定在 60 FPS，确保物体运动速度在不同电脑上保持一致。

## 三、 核心指令复盘
* `SDL_PollEvent(&event)`：非阻塞式读取系统事件。
* `SDL_KEYDOWN` / `SDLK_UP...`：识别特定的物理按键。
* `SDL_RenderFillRect`：直接指挥 GPU 在显存缓冲区填充色块（无需加载外部资源）。
* `SDL_GetTicks()`：获取系统启动后的毫秒数，用于高精度计时。

## 四、 实验结论
* **坐标系**：屏幕左上角为 $(0, 0)$，$Y$ 轴向下为正方向。
* **瞬时性**：无论一帧内坐标修改了多少次，用户只能看到 `SDL_RenderPresent` 瞬间的最终状态。

